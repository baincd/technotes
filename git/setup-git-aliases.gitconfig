################################################################################
# # Chris' Awesome Git Aliases                                                 #
#                                                                              #
# Very useful, helpful, and AWESOME! git aliases.  View the file contents to   #
# see git aliases defined.                                                     #
#                                                                              #
# ## Setup Option 1: Import into ~/.gitconfig                                  #
#                                                                              #
# 1. Create `~/.git-aliases.gitconfig`                                         #
#    a. Create symbolic link with following command                            #
#     `ln -s ~/wc/technotes/git/setup-git-aliases.gitconfig ~/.git-aliases.gitconfig` #
#    b. OR Save this file to `~/.git-aliases.gitconfig`                        #
#                                                                              #
# 2. Add to ~/.gitconfig:                                                      #
# ```                                                                          #
# [include]                                                                    #
#     path = ~/.git.gitconfig                                                  #
# ```                                                                          #
#                                                                              #
# ## Setup Option 2: Copy contents directly into ~/.gitconfig                  #
################################################################################

[alias]
  git = "!f() { cd -- ${GIT_PREFIX:-.} && git \"$@\" ; }; f" # Fix when you type `git git status` BWAHAHAHAHA
  aliases = "!f() { git config --get-regexp '^alias\\.' | sed -rne 's/^alias\\.([^ ]*).*$/\\1/p' | sort ; }; f" # List all aliases configured
  alias = "!f() { git config --get-regexp \"^alias\\.${1}\\b\" | sed -rne \"s/^alias\\.${1}\\s//p\" ; }; f" # Show the git alias command.  Usage: `git alias diffiw`

  logw = "!f() { cd -- ${GIT_PREFIX:-.} && gitk \"$@\" & }; f" # Log GUI - also accepts many parameters of `git log`
  commitw = "!f() { cd -- ${GIT_PREFIX:-.} && git gui \"$@\" & }; f" # Commit GUI

  id = rev-parse --default HEAD # Print the Git ID (by default of head, but you can pass in a commitish ref)
  info = show --pretty=fuller --name-status # Show author and committer information and list files changed (but don't show diff)

  logd = log --decorate # Log Decorated with branch information
  logg = log --graph --oneline --date=relative --format=format:'%C(bold blue)%h%C(reset) %C(bold green)%ad%C(reset) %C(bold cyan)%<(8,trunc)%an%C(reset) %s%C(bold yellow)%d%C(reset)' # Log Graph
  logv = log --graph --oneline --date=local --format=format:'%C(bold blue)%h%C(reset) %C(bold green)%ad%C(reset) %C(bold cyan)%an%C(reset) %C(bold yellow)%d%C(reset)%n%w(0,8,8)%B' # Log Verbose Graph

  addall = add -A -v # Add all files to staging area
  commitall = !git addall && git commit # Commit all changes
  pushall = !git commitall && git push # Commit all changes and push
  fixup-now = "!f() { local COMMIT=`git id $1` && git addall && git commit --fixup $COMMIT && git rebase -i $COMMIT~1 ; }; f" # Take all staged and unstaged changes and immediately fixup the commit passed in (you will need to save the interactive rebase editor)

  s = status --short --branch # Short status
  sv = status # Verbose status
  staged = diff --cached # Show staged changes
  diffiw = diff --ignore-space-change --ignore-space-at-eol # Diff Ignore Whitespace
  conflicts = "!f() { cd -- ${GIT_PREFIX:-.} && git -c color.status=always status --short | sed -nr '/^[^ A-Z]*(U[DAU]|[DAU]U|AA|DD)/p' ; }; f" # List all conflict files
  conflict = "!f() { cd -- ${GIT_PREFIX:-.} && git conflicts | sed -re 's/^[^ A-Z]*[DAU][DAU][^ A-Z]* //' -ne ${1}p ; }; f" # Return a specific conflict file

  ff = merge --ff-only # Fast Forward branch to another branch (Usage: `git ff origin/anotherbranch`)
  ffup = merge --ff-only @{u} # Fast Forward branch to upstream branch
  merge2 = merge --strategy-option=patience # Merge using a different strategy

  f = fetch --all --tags # Fetch All
  pullr = pull --rebase # Pull using rebase
  pullm = pull # Pull using Merge
  pullf = pull --ff-only # Pull using Fast Forward
  pushup = -c push.default=upstream push # Push to the upstream branch

  br = checkout -b # Create and checkout branch ex: `git br newbranch` or  `git br newbranch existingbranch`
  brr = branch -m # Branch Rename
  track = branch -u # Set tracking (upstream) branch
  untrack = branch --unset-upstream # Unset tracking (upstream) branch

  # Do a hard reset, but save all changes in the working copy to the reflog
  # Based on alias from https://haacked.com/archive/2014/07/28/github-flow-aliases/
  wipe = !git add -A && git commit -qm 'WIPE SAVEPOINT' && git --no-pager log --color=always HEAD~1..HEAD --pretty='%C(dim)%h%C(reset) %s:' --stat && echo '' && git reset HEAD~1 --hard

  # Execute a git command recursively on all git repos in subdirectories
  rec  = "!f() { cd -- ${GIT_PREFIX:-.} && find -name .git -type d -exec echo \"\" \\; -exec echo --- \\; -exec echo {} \\; -execdir git $@ \\; ; }; f"
  # Execute a git command recursively on all git repos in subdirectories, prompting for each repo
  recp = "!f() { cd -- ${GIT_PREFIX:-.} && find -name .git -type d -exec echo \"\" \\; -exec echo --- \\;                   -okdir   git $@ \\; ; }; f"
  rpullf = !git rec pullf # Recursively pull all repos in subdirectories
  rfetch = !git rec f # Recursively fetch all repos in subdirectories

  # NOTE: branches and tags output in the same format (except tags doesn't have upstream), but use different commands for the formatting (for-each-ref and log).  Also, tags can take arguments to limit the tags (and can include wildcards, like 1.0.*)
  branches = "!f() { git for-each-ref --color --sort=-committerdate refs/heads/ --format=\"%(color:green)%(committerdate:format-local:%Y-%m-%dh%H)%(color:reset) %(color:yellow)%(objectname:short)%(color:reset)%(color:bold green)%(HEAD)%(color:reset)%(color:bold cyan)%(refname:short)%(color:reset)%(if)%(upstream)%(then) %(color:yellow)(%(color:reset)%(color:magenta)%(upstream:lstrip=2)%(if)%(upstream:track)%(then) %(upstream:track)%(end)%(color:reset)%(color:yellow))%(color:reset)%(end): %(contents:subject) %(color:dim)(%(authorname))%(color:reset)\" | sed -re 's/##TIMESYMBOL##/\\x1b[32;2mH\\x1b[0m\\x1b[32m/' ; }; f" # List all branches
# Trim ahead/behind??
# git branches | sed -re 's/^([^:]*)\[ahead ([0-9]+)/\1[\x1b[36m+\2\x1b[35m/' -re 's/^([^:]*)(\[|, )behind ([0-9]+)\]/\1\2\x1b[31m-\3\x1b[35m]/
  tags = "!f() { git tag --list \"$@\" | xargs -I{} git --no-pager -c color.ui=always log {} -1 --date='format-local:%Y-%m-%dh%H' --format='format:%Cgreen%cd%Creset %C(yellow)%h%Creset %C(bold cyan){}%Creset: %s %C(dim)(%an)%Creset%n' | sort -r ; }; f"  # List all tags
  remotes = "!f() { TAB='	' ; git remote -v | sed -re \"s/^(.*)${TAB}/\\x1b[36;1m\\1\\x1b[0m${TAB}/\" | sed -re '$!N; s/(.*) \\(fetch\\)\\n\\1 \\(push\\)/\\1/' | sed -re \"$!N; s/(.*)${TAB}([^ ]*) \\(fetch\\)\\n\\1${TAB}([^ ]*) \\(push\\)/\\1\\n  fetch: \\2\\n  push:  \\3/\" ; }; f" # List all remotes

  # Remove all branches that are merged into the passed in branch/commit (excluding the current branch and the passed in branch)
  rm-merged-branches = "!f() { git f && git branch --merged \"$1\" | grep -v '\\*' | grep -v \"^ *$1$\" | xargs -n 1 git branch -D ; }; f"

  # Find all commits that have not been cherrypicked onto the branch
  unpicked-cherries = "!f() { git cherry -v $@ | sed -n 's/^+ //p'; }; f"

  # Find the merge commit that includes a specific commit
  # Usage:
  #   $ git find-merge <COMMIT_ID>  # Defaults to searching HEAD
  #   $ git find-merge <COMMIT_ID> <BRANCH>
  # Show merge will show the merge author and details
  # Reference: https://stackoverflow.com/a/30998048
  find-merge = "!sh -c 'commit=$0 && branch=${1:-HEAD} && (git rev-list $commit..$branch --ancestry-path | cat -n; git rev-list $commit..$branch --first-parent | cat -n) | sort -k2 -s | uniq -f1 -d | sort -n | tail -1 | cut -f2'"
  show-merge = "!sh -c 'merge=$(git find-merge $0 $1) && [ -n \"$merge\" ] && git show $merge'"


  # Clone only the HEAD commit (no history will be cloned)
  shallow-clone = clone --depth 1

  # Display useful tips for log command search options
  helpme-log-search = "!f () {                                                                               \
    echo \"\\033[1mSearch commit message\\033[0m\";                                                          \
    echo \"  --grep=<regex>\";                                                                               \
    echo \"    \\033[2m* By default limits to commits that match any --grep=<regex> param\\033[0m\";         \
    echo \"    \\033[2m* Use --all-match to limit to commits that match all --grep=<regex> params\\033[0m\"; \
    echo \"    \\033[2m* Use --invert-grep to limit to commits that do not match <regex>\\033[0m\";          \
    echo \"\";                                                                                               \
    echo \"\\033[1mSearch patches\\033[0m\";                                                                 \
    echo \"  -G<regex>\";                                                                                    \
    echo \"\";                                                                                               \
    echo \"\\033[1mSearch patches for change in number of occurrences\\033[0m\";                             \
    echo \"  -S<regex> --pickaxe-regex\";                                                                    \
    echo \"    \\033[2m* Do not use --pickaxe-regex to search string instead of regex\\033[0m\";             \
  }; f"
  # [`-S and -G`](https://git-scm.com/docs/git-log#git-log--Sltstringgt) \
  # [`--grep`](https://git-scm.com/docs/git-log#git-log---grepltpatterngt)

  # Display useful tips for log command output options
  helpme-log-output = "!f () {                                                       \
    echo \"--graph\";                                                                \
    echo \"--decorate (show refs)\";                                                 \
    echo \"--oneline\";                                                              \
    echo \"--format=oneline|short|medium|full|fuller|<format> (default => medium)\"; \
    echo \"--abbrev-commit\";                                                        \
    echo \"--date=relative|local|short|format:<format> (short is YYYY-MM-DD)\";      \
    echo \"--all (all refs on command line)\";                                       \
    echo \"-p (print patches)\";                                                     \
  }; f"

  # Display useful tips for viewing diffs of merge commits in log command
  helpme-log-merge-diff = "!f () {                                                                          \
    echo \"\\033[1mCombined diff from each parent\\033[0m\";                                                \
    echo \"  -c\";                                                                                          \
    echo \"    \\033[2mShow the differences from each of the parents to the merge result\\033[0m\";         \
    echo \"    \\033[2msimultaneously, listing only files which were modified from all parents\\033[0m\";   \
    echo \"\";                                                                                              \
    echo \"\\033[1mCombined diff from each parent (interesting changes only)\\033[0m\";                     \
    echo \"  --cc\";                                                                                        \
    echo \"    \\033[2mSame as -c option but omitting uninteresting hunks\\033[0m\";                        \
    echo \"\";                                                                                              \
     echo \"\\033[1mSplit diff for each parent\\033[0m\";                                                   \
    echo \"  -p -m\";                                                                                       \
    echo \"    \\033[2mShow the full diff like regular commits for each merge parent. A separate\\033[0m\"; \
    echo \"    \\033[2mlog entry and diff is generated for each parent\\033[0m\";                           \
    echo \"\";                                                                                              \
    echo \"\\033[1mDiff only with first parent (branch merged into)\\033[0m\";                              \
    echo \"  -p -m --first-parent\";                                                                        \
    echo \"    \\033[2mShow only the changes the merge brought into the then-current branch\\033[0m\";      \
  }; f"

# The feature-* aliases use feature-alias.main-branch to determine where to branch from and return to.
# The default is master.
# - To change this globally
#   - edit ~/.gitconfig and add this config setting
#   - OR run command `git config --global feature-alias.main-branch new-mainline-branch`
# - To change this for a single repo
#   - edit .git/config and add this config setting
#   - OR run command `git config feature-alias.main-branch new-mainline-branch`
[feature-alias]
	main-branch = master
[alias]

  # Fetch and create a new branch off of origin/main-branch (see feature-alias.main-branch)
  # Usage: `git feature-start my-new-feature`
  feature-start = "!f () {                                                  \
    cd -- ${GIT_PREFIX:-.};                                                 \
    if test -n \"$(git status --short 2> /dev/null)\"; then                 \
      echo \"\\033[01;31mERROR!\\033[0m Working Copy isn't clean!\";        \
    else                                                                    \
      local MAINLINE_BRANCH=\"$(git config feature-alias.main-branch)\" &&  \
      git fetch --all &&                                                    \
      git br \"$1\" origin/$MAINLINE_BRANCH;                                \
    fi;                                                                     \
  }; f"

  # Fetch, checkout main-branch (create if necessary), and delete current feature branch (see feature-alias.main-branch)
  feature-end = "!f () {                                                            \
    cd -- ${GIT_PREFIX:-.};                                                         \
    if test -n \"$(git status --short 2> /dev/null)\"; then                         \
      echo \"\\033[01;31mERROR!\\033[0m Working Copy isn't clean!\";                \
    else                                                                            \
      local OLD_BRANCH=\"$(git rev-parse --abbrev-ref HEAD 2> /dev/null)\" &&       \
      local MAINLINE_BRANCH=\"$(git config feature-alias.main-branch)\" &&          \
      git fetch --all &&                                                            \
      (git branch $MAINLINE_BRANCH origin/$MAINLINE_BRANCH 2> /dev/null || true) && \
      git checkout $MAINLINE_BRANCH &&                                              \
      (git ffup || true)  &&                                                        \
      git branch -D \"$OLD_BRANCH\";                                                \
    fi;                                                                             \
  }; f"

  # Equivalent to `git feature-end && git feature-start <branchname>`
  feature-swap = "!f() { git feature-end &&  git feature-start "$@" ; }; f"

  # Quick Stash - Commit all changes with the commit message starting with "WIP!"
  # Usage: `git qstash` OR `git qstash "Added FooBar"`
  # Can be used to commit frequently so code can be rolled back quickly to a good state
  # or to store changes on the branch temporarily so a different branch can be checked out
  # see qunstash
  qstash = "!f() {                                                                                             \
    cd -- ${GIT_PREFIX:-.};                                                                                    \
    if test -z \"$(git status --short 2> /dev/null)\"; then                                                    \
      echo -e \"\\033[01;31mERROR!\\033[0m: No changes to stash!\";                                            \
    else                                                                                                       \
      git add -A &&                                                                                            \
      git commit -qm \"WIP! $1\" &&                                                                            \
      git --no-pager log --color=always --oneline HEAD~1..HEAD --pretty=\"%C(dim)%h%C(reset) %s\" --stat;      \
    fi;                                                                                                        \
  }; f"

  # Remove commits added by qstash, leaving changes to working copy
  # Usage:
  #    `git qunstash` - remove only the HEAD commit
  #    `git qunstash --all` - remove all consecutive qstash'd commits
  qunstash = "!f() {                                                                                          \
    cd -- ${GIT_PREFIX:-.};                                                                                   \
    local HEAD_WIP=\"$(git log HEAD~1..HEAD --format='%H' --grep '^WIP')\";                                   \
    if test -z $HEAD_WIP; then                                                                                \
      echo \"\\033[01;31mERROR!\\033[0m Head not a WIP\";                                                     \
    else                                                                                                      \
      if test \"${1}\" = \"--all\"; then                                                                      \
        local NEW_HEAD=\"$(git log HEAD --format='%H' --grep '^WIP' --invert-grep | head -1)\";               \
      else                                                                                                    \
        local NEW_HEAD=\"HEAD~1\";                                                                            \
      fi &&                                                                                                   \
      git reset $NEW_HEAD >> /dev/null &&                                                                     \
      local MARKER=\"##-##-##-##-##\" &&                                                                      \
      git log --color=always HEAD..$HEAD_WIP --pretty=\"Unstashed: %C(dim)%h%C(reset) %C(bold green)${MARKER}%ad${MARKER}%C(reset) %s\" | sed -r \"s/${MARKER}(.{16}).*${MARKER}/\\1/\" ; \
    fi;                                                                                                       \
  }; f"

  qunstashall = "!git qunstash --all"

  # Remove files that should not be tracked from the index, fix line endings and permissions
  hard-reset-index = "!f () {                                                        \
      if test -n \"$(git status --short 2> /dev/null)\"; then                        \
        echo \"\\033[01;31mERROR!\\033[0m Working Copy isn't clean!\";               \
      else                                                                           \
        git rm -r -q --cached . &&                                                   \
        git add . ;                                                                  \
      fi;                                                                            \
    }; f"

  # Cache SSH credentials
  # setup in ~/.bashrc
  # alias ssh-cache='eval `ssh-agent` && ssh-add'
